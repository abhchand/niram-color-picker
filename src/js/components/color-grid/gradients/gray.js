import { generateHSLGradient } from 'helpers/hsl';
import Gradient from 'models/gradient';
import { GRADIENT_LEN } from '../constants';
import RGBColor from 'models/rgb-color';
import { shuffleArray } from 'helpers/array';

/*
 * It's easier to generate gray-ish colors in the
 * RGB color space and then convert them to HSL.
 */

/*
 * Generate values for the base color in the middle of the
 * RGB color space so we have room above and below to generate
 * a gradient of darker and lighter colors.
 */

const COLOR_LOWER = Math.round(0.4 * 255);
const COLOR_UPPER = Math.round(0.6 * 255);

// R, G, and B values will be selected within `DELTA` distance of each other
const DELTA = 10;

/*
 * We convert the RGB to HSL below before generating the gradient, so
 * these values still need to be specified as HSL color space values.
 * Grays in the HSL space correspond to values near the center of
 * the cylinder, so we keep the Saturation range small (so it doesn't
 * get too far from the center) and we keep the luminance small as
 * well (so it doesn't get too dark or light near the edges).
 */
const S_GRADIENT_RANGE = 0.05;
const L_GRADIENT_RANGE = 0.2;

/*
 * Generates a series of `Gradient`s with gray base
 * colors in the HSL color space.
 *
 * Gradients are generated such that their
 * base colors are somewhat (but not prefectly) spaced
 * around the HSL color space to avoid two similar colors.
 *
 * Generates a total of `count` `Gradient` objects.
 */
const generateGrayGradients = (count) => {
  /*
   * It's easier to generate gray-ish colors in the
   * RGB color space and then convert them to HSL.
   *
   * RGB Gray's are generated by selecting R, G, and B
   * values close to each other.
   *
   * When all three values are equal, they produce a pure
   * gray. However for some variation, we randomly select
   * 3 channels within `DELTA` units of each other.
   *
   * We also randomize the order of R, G, and B so that
   * we generate values across several Hues in the HSL color
   * space.
   */

  const gradients = [];

  for (let i = 1; i <= count; i++) {
    const color = COLOR_LOWER + (COLOR_UPPER - COLOR_LOWER) * Math.random();
    const rgb = shuffleArray([
      color,
      color + DELTA * Math.random(),
      color + DELTA * Math.random()
    ]);

    /*
     * Generate the base color, specifying the H, S, and L
     * bounds.
     */
    const baseColor = new RGBColor(rgb[0], rgb[1], rgb[2]).toHSL();

    // Generate the gradient around the base color
    gradients.push(
      generateHSLGradient(
        baseColor,
        GRADIENT_LEN,
        S_GRADIENT_RANGE,
        L_GRADIENT_RANGE
      )
    );
  }

  return gradients;
};

/*
 * Generates a series of `Gradient`s in the HSL color space
 * given a list of (gray) base colors
 */
const generateGrayGradientsFromBaseColors = (baseColors) => {
  return baseColors.map((baseColor) => {
    return generateHSLGradient(
      baseColor.toHSL(),
      GRADIENT_LEN,
      S_GRADIENT_RANGE,
      L_GRADIENT_RANGE
    );
  });
};

export { generateGrayGradients, generateGrayGradientsFromBaseColors };
